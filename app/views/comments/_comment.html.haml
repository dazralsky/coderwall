%li.cf.comment{class: top_comment?(comment, comment_counter) ? 'top-comment' : '' , id: "comment_#{comment.id}", itemscope: true, itemtype: meta_comment_schema_url, itemprop: :comment}
  %meta{itemprop: :commentTime, content: comment.created_at}
  %meta{itemprop: :name, content: comment.id}
  %header.cf{itemprop: "creator", itemscope: true ,itemtype: meta_person_schema_url}
    %meta{itemprop: :name, content: comment.user.display_name}
    %meta{itemprop: :alternateName, content: comment.user.username}
    .comment-avatar
      = image_tag(users_image_path(comment.user), class: 'avatar')
    %a.comment-user{href: profile_path(comment.user.username), 'data-reply-to' => comment.user.username, itemprop: 'creator'}
      = comment.user.username
    %a.like{href:like_protip_comment_path(comment.commentable.try(:public_id), comment.id), 'data-remote' => 'true', 'data-method' => :post, class: comment_liked_class(comment), rel: "nofollow"}
      = comment_likes(comment)
  .comment{itemprop: :commentText}
    = raw sanitize(formatted_comment(comment.body))
    - if can_edit_comment?(comment)
      .edit-comment.hidden
        = form_for [comment.commentable, comment] do |f|
          = f.text_area :comment, label: false, rows: 5
          %input{type: 'submit', value: 'Save', class: 'button save'}
          %input{type: 'button', value: 'Cancel', class: 'button cancel'}
  %ul.edit-del.cf
    - if signed_in?
      %li.hidden.show-for-user{'data-user' => comment.user.username}
        %a.edit{href: '#', onclick: 'return false;'}
          Edit
      %li.hidden.show-for-user{'data-user' => comment.user.username}
        %a.delete{href: protip_comment_path(comment.commentable.try(:public_id), comment.id), 'data-method' => :delete}
          Delete
      %li.remove-for-user{'data-user' => comment.user.username}
        %a.reply{href: '#add-comment', rel: 'nofollow'}
          Reply
